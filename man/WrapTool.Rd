% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/00_Wrappers.R
\name{WrapTool}
\alias{WrapTool}
\title{Generate a projection or clustering tool wrapper}
\usage{
WrapTool(
  name,
  type,
  r_packages = NULL,
  python_modules = NULL,
  fun.build_model.single_input = NULL,
  fun.build_model.batch_input = NULL,
  fun.build_model = NULL,
  fun.extract = function(model) model,
  fun.apply_model.single_input = NULL,
  fun.apply_model.batch_input = NULL,
  fun.apply_model = NULL,
  prevent_parallel_execution = TRUE,
  use_python = !is.null(python_modules) && length(python_modules) > 0,
  use_original_expression_matrix = FALSE,
  use_knn_graph = FALSE
)
}
\arguments{
\item{name}{string: name of tool}

\item{type}{string: type of tool type (either '\code{projection}' or '\code{clustering}')}

\item{r_packages}{string vector: names of all \code{R} packages needed by the modelling functions}

\item{python_modules}{optional string vector: names of \code{Python} modules needed by the modelling function (called via \code{reticulate}). Default value is \code{NULL}}

\item{fun.build_model.single_input}{optional function: modelling function which accepts a single coordinate matrix as input data. Minimal signature \code{function(input, latent_dim)} or \code{function(input, n_clusters)}}

\item{fun.build_model.batch_input}{optional function: modelling function which accepts a list of coordinate matrices as input data. Minimal signature \code{function(input, latent_dim)} or \code{function(input, n_clusters)}. Default value is \code{NULL}}

\item{fun.build_model}{optional function: different parameter name for \code{fun.build_model.single_input}, if \code{fun.build_model.batch_input} is left as \code{NULL}}

\item{fun.extract}{optional function: modelling function which accepts a model generated by \code{fun.build_model.single_input} or \code{fun.build_model.batch_input} as input. Signature \code{function(model)}. If unspecified, the \code{model} object itself is taken as result}

\item{fun.apply_model.single_input}{optional function: modelling function which accepts a model generated by \code{fun.build_model.single_input} or \code{fun.build_model.batch_input} and new coordinate matrix as input. Signature \code{function(model, input)}. Default value is \code{NULL}}

\item{fun.apply_model.batch_input}{optional function: modelling function which accepts a model generated by \code{fun.build_model.single_input} or \code{fun.build_model.batch_input} and a new list coordinate matrices as input. Signature \code{function(model, input)}. Default value is \code{NULL}}

\item{fun.apply_model}{optional function: different parameter name for \code{fun.apply_model.single_input}, if \code{fun.apply_model.batch_input} is left as \code{NULL}}

\item{prevent_parallel_execution}{logical: whether running the tool in parallel on multiple CPU cores should be prevented. Default value is \code{TRUE}}

\item{use_python}{logical: whether the tool uses \code{Python} via \code{reticulate}. This is automatically set to \code{TRUE} if any \code{Python} modules are required. Otherwise, default value is \code{FALSE}}

\item{use_original_expression_matrix}{logical: whether the tool uses original expression matrix apart from the output of the preceding dimension-reduction tool. Default value is \code{FALSE}}

\item{use_knn_graph}{logical: whether the tool uses a \code{k}-nearest-neighbour graph of the input data. Default value is \code{FALSE}}
}
\value{
This function returns a wrapper function that can be used in constructing a benchmark pipeline using \code{Fix}, \code{Module} and \code{Subpipeline}.
}
\description{
This function lets you create wrappers of projection or clustering tools.
Then, you can include them in benchmark pipelines.
}
\section{Basic components of a tool wrapper}{
To create a wrapper, you need to specify a handful of components (as arguments to \code{WrapTool}).
\code{name} is a unique string identifier. This is also included in the name of the wrapper (for example, \code{FlowSOM} will have \code{wrapper.clustering.FlowSOM}).
\code{type} specifies whether it is a projection tool (for dimension reduction or denoising) or clustering tool.
The string vector \code{r_packages} specifies names all required \code{R} packages and \code{python_modules} specifies names of required \code{Python} modules (that will be accessed via \code{reticulate}: the \code{R}/\code{Python} interface).
}

\section{Modelling functions}{
Modelling functions are the ones that do the work: transform input data.
At least one of them (\code{fun.build_model}) needs to be specified.

\code{fun.build_model.single_input} takes a single coordinate matrix of data and returns a model.
The model is an object from which the desired result (projection coordinate matrix or vector of cluster indices per data point) can be extracted.
\code{fun.build_model.batch_input}, instead, takes a list of multiple coordinate matrices (one per sample) as input and returns a model.

If the tool does not distinguish between a single input matrix and multiple input matrices (it would just concatenate the inputs and apply \code{fun.build_model.single_input}), \code{fun.build_model.batch_input} can be left unspecified and it will be auto-generated.
In that case, you can  specify the function summarily as \code{fun.build_model}.

\code{fun.extract} is a function that takes a model object (generated by \code{fun.build_model...}) as input and extracts results of the model applied to the original input data.
\code{fun.apply_model.single_input} takes a model object and a \emph{new} coordinate matrix as input.
It returns the result of applying the \emph{previously} trained model on \emph{new} data.
\code{fun.apply_model.batch_input} takes a list of coordinate matrices as input and applies the model to new data.

Results of the \code{...batch_input} functions should not be split up into lists according to the sizes of the original inputs: they always return a single coordinate matrix or cluster vector (the splitting per sample is implemented automatically).
\subsection{Minimal function signatures}{

The minimal signature of a \code{fun.build_model...} function is \code{function(input)}.
Other arguments, with their default values, can (and should) be included: that way, changes in other parameters can be tested.

For example, a simple signature of a \code{fun.build_model...} function for the dimension-reduction tool \code{t-SNE} might be \code{function(input, latent_dim = 2, perplexity = 2)}, allowing the user to alter target dimensionality or the perplexity parameter.

Signatures of the other modelling functions are fixed.
For \code{fun.extract} it is \code{function(model)} and for \code{fun.apply_model...} it is \code{function(model, input)}.
}

\subsection{Additional inputs to model-building functions}{

If a clustering tool uses the original high-dimensional expression data as well as a projection (generated in the previous step by some projection method), then include the parameter \code{expression} in your function signature and set parameter \code{use_original_expression_matrix} to \code{TRUE}.
\code{expression} is either a single matrix or a list of matrices, much like \code{input}.
\code{input}, then, will be the output of the preceding projection tool in that given sub-pipeline.

If your tool uses a \code{k}-nearest_neighbour graph (k-NNG), you are encouraged to always use one that was computed at the beginning of your pipeline evaluation.
(The \code{k}-NNG will be created if \code{SingleBench} knows it will run one or more tool that need it.)
To do this, set \code{use_knn_graph} to \code{TRUE} and add the argument \code{knn} to the signature of your model-building functions.
\code{knn} will then be a list of two names matrices: \code{Indices} for indices of nearest neighbours (row-wise) and \code{Distances} for distances to those neighbours.

\strong{Warning}: the entries in \code{Indices} will be \code{1}-indexed and the matrices do not contain a column for the 'zero-th' neighbour (for each point, the zero-th neighbour is itself).
To modify the \code{knn} object (switch to 0-indexing or include zero-th neighobur), use the convertor \code{kNNTweak} inside your model-building function.
For instance, to convert \code{knn} to only a matrix of indices that does include zero-th neighbours, is 1-indexed and \code{k} is lowered from its original value to \code{30}, use: \code{knn <- kNNGTweak(knn, only_indices = TRUE, zero_index = TRUE, zeroth_neighbours = TRUE, new_k = 30)}.
}

\subsection{\emph{n}-parameters}{

Most tools can accept custom numeric parameters.
Any one of the arguments to a model-building function can be chosen as the \emph{n}-parameter by the user: then, \code{SingleBench} can do parameter sweeps over different values of these parameters.
Dimension-reduction tools, if possible, should have a parameter \code{latent_dim} for iterating over latent-space dimensionality.
Clustering tools, if possible, should have a parameter \code{n_clusters} for iterating over target cluster count.
If there is an option to determine number of clusters automatically, it might be a good idea to use \code{n_clusters = 0} for this.

For methods that are made to run on multiple CPU cores, set \code{prevent_parallel_execution} to \code{TRUE} (otherwise, \code{SingleBench} may attempt to run them in parallel if the user wants repeated runs for stability analysis).
}
}

