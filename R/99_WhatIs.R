
#' Inspect a specific cluster or annotated population
#'
#' The identity of a cell subset (cluster or annotated population) is inspected in terms of its overall distribution of signal per marker, and correlations between markers at a single-cell level (indicating) cell-level patterns.
#' 
#' Alternatively, a biaxial expression plot for the given cell subset can be generated by specifying two markers of interest to plot against each other.
#' 
#' @param benchmark object of type \code{Benchmark}
#' @param idx.subpipeline integer: index of subpipeline (if a cluster is to be retrieved). Default value is \code{NULL}
#' @param idx.n_param integer: *n*-parameter iteration index (if a cluster is to be retrieved and *n*-parameter was specified in the benchmark set-up). Default value is \code{NULL}
#' @param idx.run integer: which clustering run to use if clustering was run repeatedly. Default value is \code{1}
#' @param cluster integer: index of cluster of interest (if a cluster is to be retrieved). Default value is \code{NULL}
#' @param population string: name of population of interest (if a population is to be retrieved). Default value is \code{NULL}
#' @param marker1 string: optional name of marker-of-interest on x-axis for biaxial expression plot. Default value is \code{NULL}
#' @param marker2 string: optional name of marker-of-interest on y-axis for biaxial expression plot. Default value is \code{NULL}
#' @param pointsize_bg numeric: point size for plotting signal distribution from background (all) cells. Default value is \code{0.7}
#' @param pointsize_fg numeric: point size for plotting signal distribution from foreground (cluster-/population-specific) cells. Default value is \code{1.2}
#'
#' @export
WhatIs <- function(
  benchmark,
  idx.subpipeline = 1,
  idx.n_param = NULL,
  idx.run = 1,
  cluster = NULL,
  population = NULL,
  marker1 = NULL,
  marker2 = NULL,
  pointsize_bg = 0.7,
  pointsize_fg = 1.2,
  exprs = NULL
) {
  .WhatIs.ValidityChecks(environment())

  if (is.null(exprs)) {
    exprs <- GetExpressionMatrix(benchmark, concatenate = TRUE)[, benchmark$column_names]
  }
  
  if (!is.null(cluster)) {
    
    cv <- GetClustering(benchmark, idx.subpipeline, idx.n_param, idx.run, concatenate = TRUE)
    mask <- cv==cluster
    n <- sum(mask)
    N <- length(mask)
    perc <- round(n/N*100, 2)
    title <- paste0('Cluster ', cluster, ': ', n, '/', N, ' cells (', perc,'%)')
  } else if (!is.null(population)) {
    
    ann <- GetAnnotation(benchmark, concatenate = TRUE)
    mask <- ann==population
    n <- sum(mask)
    N <- length(mask)
    perc <- round(n/N*100, 2)
    title <- paste0(population, ': ', n, '/', N, ' cells (', perc,'%)')
  }
  
  if (n==0) {
    return(ggplot()+theme_void()+theme(plot.title=ggtext::element_markdown(hjust=.5))+ggtitle(title))
  }
  
  if (!is.null(marker1) && !is.null(marker2)) {
    
    stopifnot(marker1%in%colnames(exprs))
    stopifnot(marker2%in%colnames(exprs))
    
    res <- ggplot() +
      theme_minimal() +
      scattermore::geom_scattermost(
        xy = exprs[, c(marker1, marker2)],
        color = 'darkgrey',pointsize=pointsize_bg
      ) +
      scattermore::geom_scattermost(
        xy = exprs[mask, c(marker1, marker2)],
        color = 'coral',pointsize=pointsize_fg
      ) +xlab(marker1)+ylab(marker2) +
      ggtitle(title) +
      theme(plot.title=element_text(hjust=.5))
  } else {
    
    dfull <- tidyr::pivot_longer(
      data.frame(exprs, check.names = FALSE),
      cols = tidyselect::everything()
    ) %>% 
      dplyr::mutate(name = as.factor(name)) %>% 
      dplyr::mutate(idx = as.integer(name))
    m <- levels(dfull$name)
    
    d <- tidyr::pivot_longer(
      data.frame(exprs[mask, ], check.names = FALSE),
      cols = tidyselect::everything()
    ) %>% 
      dplyr::mutate(name = factor(name, levels = m)) %>% 
      dplyr::mutate(idx = as.integer(name))
    
    set.seed(1); d$idx <- d$idx + rnorm(nrow(d), 0, 0.1)
    set.seed(1); dfull$idx <- dfull$idx + rnorm(nrow(dfull), 0, 0.1)
    
    p_par <- ggplot() +
      scattermore::geom_scattermost(
        xy = cbind(dfull$value, dfull$idx),
        color = 'darkgrey',
        pointsize = pointsize_bg
      ) +
      scattermore::geom_scattermost(
        xy = cbind(d$value, d$idx),
        color = 'coral',
        pointsize = pointsize_fg
      ) +
      scale_y_discrete('Parameter', limits = m) +
      ylab('Signal') +
      theme_minimal() +
      theme(axis.text.x = element_text(vjust = 0.5, hjust = 0))
    
    cor <- Hmisc::rcorr(exprs[mask, rev(m)], type = 'spearman')
    r <- cor$r
    diag(r) <- NA
    r[which(upper.tri(r))] <- NA
    
    sr <- matrix(as.character(round(r, 2)),nrow=nrow(r),ncol=ncol(r))
    sr[is.na(sr)] <- ''
    sr <- sub('0.', '.', sr)
    
    p_cor <- pheatmap::pheatmap(r, silent = TRUE, cluster_cols = FALSE, cluster_rows = FALSE, fontsize = 7, display_numbers=sr, na_col='white')
    
    grob_classes <- purrr::map(p_cor$gtable$grobs, class)
    idx_grob <- which(purrr::map_lgl(grob_classes, function(cl) 'gTree' %in% cl))[1]
    grob_names <- names(p_cor$gtable$grobs[[idx_grob]]$children)
    idx_rect <- grob_names[grep('rect', grob_names)][1]
    p_cor$gtable$grobs[[idx_grob]]$children[[idx_rect]]$gp$col <- 'black'
    p_cor$gtable$grobs[[idx_grob]]$children[[idx_rect]]$gp$lwd <- 0.1
    
    res <- cowplot::plot_grid(
      grid::textGrob(title, gp = grid::gpar(lty = 2, fontsize = 12)),
      
      cowplot::plot_grid(
        cowplot::plot_grid(
          grid::textGrob('Marker expression versus background', gp = grid::gpar(lty = 2, fontsize = 10)),
          p_par,
          ncol = 1, rel_heights = c(1, 20)
        ),
        cowplot::plot_grid(
          grid::textGrob('Spearman correlations', gp = grid::gpar(lty = 2, fontsize = 10)),
          p_cor[[4]],
          ncol = 1, rel_heights = c(1, 20)
        ),
        nrow = 1
      ),
      
      nrow = 2,
      rel_heights = c(1, 20)
    )
  }
  res
}
